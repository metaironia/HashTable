# Работа по хэш-таблице

Хэш-таблица - это такая структура данных, в которой вставка, поиск и удаление элемента происходит за $ O(1)$ в лучшем случае. Выглядит она так (картинка взята [отсюда](https://khalilstemmler.com/blogs/data-structures-algorithms/hash-tables/)):

![hash_table_example](readme_images/hash_table_example.png)

### Общий принцип ее работы

Общий принцип ее работы таков: пусть мы вставляем элемент в хеш-таблицу. Как выбирается ячейка хэш-таблицы, в которую нужно вставить элемент? На вход хэш-функции поступает ключ (или слово), из которого хэш-функция получает некое числовое значение. Это числовое значение и будет являться номером ячейки хэш-таблицы, в которую стоит положить элемент. 

Для поиска и удаления алгоритм выбора ячейки хэш-таблицы такой же.

### Устройство нашей хэш-таблицы 

В качестве ячейки хэш-таблицы будет использоваться самописный двусвязный список. Сама хэш-таблица будет представлять из себя массив таких двусвязных списков. 

#### Функции нашей хэш-таблицы

Удаление элемента из хэш-таблицы нас интересовать не будет, такой функции поддерживаться не будет. 

Будет поддерживаться вставка и поиск элемента в хэш-таблице. 
В качестве элемента будет выступать слово. 

Вставка будет происходить таким образом, чтобы два одинаковых слова в хэш-таблице не встречалось (в одной ячейке не может быть два одинаковых слова). Следует уточнить, что значение, полученное хэш-функцией, может превосходить размер хэш-таблицы. В этом случае номер ячейки хэш-таблицы будет остаток от деления значения хэш-функции на размер хэш-таблицы.

Поиск элемента будет происходить по общему алгоритма поиска в хэш-таблице.

## Первая часть работы

### Цель первой части работы

Цель первой части работы заключается в исследовании распределения значений восьми хэш-функций. Подробнее см. ниже.

### Метод исследования

Для исследования будем использовать нашу хэш-таблицу. В качестве данных для вставки в хэш-таблицу возьмем набор слов, использующихся в произведении У.Шекспира "Гамлет, принц датский" (см. [hamlet.txt](src/hamlet.txt)). Это позволит нам исследовать поведение хэш-функций не на искусственно сгенерированных данных, а на реальных, что лучше. После вставки всех слов в хэш-таблицу необходимо будет сделать дамп населенности хэш-таблицы. Используя этот дамп, будем строить диаграмму населенности хэш-таблицы.

Работать будем с лоад-фактором (или населенностью) хэш-таблицы около 7. Это позволит нам лучше исследовать поведение хэш-функций, так как диапазон значений хэш-функций (в среднем) больше размера хэш-таблицы.

### Скрипт, считающий количество слов в тексте

Мой скрипт будет из текста делать файл, в котором на каждой строке будет находиться одно слово, при этом убирая различные знаки препинания. Важно отметить, что слова в выходном файле скрипта могут повторяться.

Количество уникальных слов в тексте произведения У.Шекспира "Гамлет, принц датский" после работы моего скрипта составляет
????.

    уточнить кол-во слов

### Размер хэш-таблицы

Стоит обговорить и размер хэш-таблицы. Ее размер должен быть простым числом. Почему? 

Допустим, что хэш-функция выдает значения, кратные 100. Если размер хэш-таблицы будет равен 100, то будут создаваться пики населенности, которые не будут отражать суть распределения значений хэш-функции. Чтобы избежать такого, размер хэш-таблицы стоит выбирать как простое число. Это позволит избежать искусственных пиков населенности.  

В нашем случае для того, чтобы лоад-фактор хэш-таблицы был ~= 7, размер хэш-таблицы будет равен 787.

### Исследуемые хэш-функции

#### Первая хэш-функция

Код первой хэш-функции выглядит так:

```c
uint32_t FirstHash (const HashTableElem_t value) {

    return 0;
}
```

То есть она всегда возвращает 0 вне зависимости от входной строки.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
First hash:
variance of elements in hash table = 38262.41
```

### Вторая хэш-функция

Код второй хэш-функции:
```c
uint32_t SecondHash (const HashTableElem_t value) {

    return ((int64_t) value[0]);
}
```

Она возвращает ASCII-код первой буквы слова. 

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Second hash:
variance of elements in hash table = 1565.59
```

### Третья хэш-функция 

Код третьей хэш-функции:
```c
uint32_t ThirdHash (const HashTableElem_t value) {

    return ((uint32_t) strlen (value));
}
```

Она возвращает длину слова.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Third hash:
variance of elements in hash table = 5184.90
```

### Четвертая хэш-функция

Код четвертой хэш-функции:
```c
uint32_t FourthHash (const HashTableElem_t value) {

    uint32_t ascii_codes_sum = 0;
    uint32_t word_length     = (uint32_t) strlen (value);

    for (size_t i = 0; i < word_length; i++)
        ascii_codes_sum += value[i];

    return ascii_codes_sum;
}
```
Она возвращает сумму всех ASCII-кодов слова.

Исследование этой хэш-функции будет производиться в двух случаях: 
1. При лоад-факторе хэш-таблицы ~=7;
2. При размере хэш-таблицы = 101.

#### Часть 1

Исследование при лоад-факторе хэш-таблицы ~=7.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Fourth hash, load factor ~= 7:
variance of elements in hash table = 82.41 
```

#### Часть 2

Исследование при размере хэш-таблицы = 101.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Fourth hash, hash table capacity = 101:
variance of elements in hash table = 3396.54 
```

#### Почему такое отличие



### Пятая хэш-функция

Код пятой хэш-функции:
```c
uint32_t FifthHash (const HashTableElem_t value) {

    uint32_t ascii_codes_sum = 0;

    uint32_t word_length = (uint32_t) strlen (value);

    for (size_t i = 0; i < word_length; i++)
        ascii_codes_sum += value[i];

    return ((uint32_t) (ascii_codes_sum / word_length));
}
```

Она возвращает округленный до целого результат деления суммы всех ASCII-кодов слова на длину слова.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Fifth hash:
variance of elements in hash table = 2645.65 
```

### Шестая хэш-функция

Код шестой хэш-функции:
```c
uint32_t SixthHash (const HashTableElem_t value) {

    uint32_t word_length = (uint32_t) strlen (value);

    if (word_length == 0)
        return 0;

    uint32_t hash = value[0];

    for (size_t i = 1; i <= word_length; i++) {

        hash = MyRor (hash, 1);
        hash ^= value[i];
    }

    return hash;
}
```

`MyRor()` - функция, выполняющая циклический побитовый сдвиг вправо. Так, например, `MyRor(a, b)` выполнит циклический сдвиг вправо на `b` позиций над числом `a` и вернет получившееся число.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Sixth hash:
variance of elements in hash table = 69.84  
```

### Седьмая хэш-функция

Код седьмой хэш-функции ничем не отличается от шестой за исключением того, что вместо `MyRor` в ней используется `MyRol`:
```c
uint32_t SeventhHash (const HashTableElem_t value) {

    uint32_t word_length = (uint32_t) strlen (value);

    if (word_length == 0)
        return 0;

    uint32_t hash = value[0];

    for (size_t i = 1; i <= word_length; i++) {

        hash = MyRol (hash, 1);
        hash ^= value[i];
    }

    return hash;
}
```

`MyRol()` - функция, выполняющая циклический побитовый сдвиг влево.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Seventh hash:
variance of elements in hash table = 57.44   
```

#### Отличия распределений шестой и седьмой хэш-функций

    пару слов о различии

### Восьмая хэш-функция

В качестве восьмой хэш-функции будет выступать MurmurHash3_32. Сид у такой хэш-функции будет постоянен и равен 0.

Диаграмма распределения такой хэш-функции:

    вставить картинку

Дисперсия такого распределения:
```
Eighth hash:
variance of elements in hash table = 55.37  
```

Можно заметить, что эта хэш-функция показывает лучшее распределение среди представленных в этой работе.

    вывод об этих хэш-функциях


### Вывод о распределениях этих хэш-функций

Таблица дисперсий исследуемых хэш-функций:

| Номер хэш-функции           | Дисперсия           |
| :-------------------------: | :-----------------: |
| 1 (always zero)             | $ 3.8 \cdot 10^4 $  |
| 2 (first char ASCII)        | $ 1.6 \cdot 10^3 $  |
| 3 (len)                     | $ 5.2 \cdot 10^3 $  |
| 4, (ASCII sum) лоад-фактор ~= 7         | $ 82.41 $           |
| 4, (ASCII sum) размер хэш-таблицы = 101 | $ 3.4 \cdot 10^3 $  |
| 5 (ASCII sum / len)         | $ 2.6 \cdot 10^3 $  |
| 6 (ror)                     | $ 69.84 $           |
| 7 (rol)                     | $ 57.44 $           |
| 8 (MurmurHash)              | $ 55.37 $           |



## Вторая часть работы

### Цель второй части работы

Во второй части работы необходимо оптимизировать поиск по хэш-таблице (сделать его быстрее). Необходимо сделать 3 оптимизации, используя 3 разных инструмента:
- встроенный в C ассемблер;
- внешний ассемблер;
- intrinsic функции.

### Встроенный в C ассемблер



### Внешний ассемблер

### Intrinsic функции




